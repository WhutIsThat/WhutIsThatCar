<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Kenteken Scanner — Strak & Robuust</title>

<!-- STYLING: iOS-like, natuurlijke tinten (wit / grijs / olijf / warme 'krimp') -->
<style>
:root{
  --bg: #f6f6f6;           /* zacht wit / canvas */
  --card: #ffffff;         /* kaarten */
  --muted: #8b8f93;        /* grijs */
  --olive: #707a2a;        /* olijf */
  --krimp: #8b5e3c;        /* warme bruine/terracotta */
  --accent: var(--olive);
  --radius: 14px;
  --maxw: 980px;
  font-family: -apple-system, BlinkMacSystemFont, "San Francisco", "SF Pro Text",
               "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}

html,body{height:100%;margin:0;background:var(--bg);color:#072018}
.container{max-width:var(--maxw);margin:18px auto;padding:0 16px}

/* FULLSCREEN CAMERA */
#cameraRoot{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;z-index:80}
video#cam{width:100%;height:100%;object-fit:cover;border-radius:0;display:block}
.overlay{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center}
.plateBox{
  width:64%; max-width:820px; aspect-ratio:4/1; border-radius:12px;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
  border: 2px solid rgba(255,255,255,0.95);
  box-shadow: 0 8px 30px rgba(0,0,0,0.45) inset;
  display:flex;align-items:center;justify-content:center;padding:8px;font-weight:700;color:rgba(255,255,255,0.95);
  letter-spacing:0.06em;
}
.hintBadge{
  position:absolute;top:16px;left:16px;background:rgba(255,255,255,0.9);color:#1b1b1b;padding:8px 10px;border-radius:10px;font-weight:600;font-size:0.95rem;
  box-shadow:0 6px 20px rgba(0,0,0,0.15);
}

/* top controls (hidden on small screens) */
.controls{position:absolute;bottom:18px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:90}
.btn{
  background:var(--card); border:0;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700;
  box-shadow:0 6px 18px rgba(11,12,12,0.08);
}
.btn.secondary{background:transparent;border:1px solid rgba(255,255,255,0.12);color:#fff}
.btn.capture{background:linear-gradient(90deg,var(--olive),var(--krimp));color:#fff}

/* APP (result) */
#app{display:none;position:relative;z-index:100;padding:18px;margin:18px auto;width:100%;max-width:var(--maxw);box-sizing:border-box}
.card{background:var(--card);border-radius:var(--radius);padding:16px;box-shadow:0 8px 30px rgba(2,6,23,0.06);color:#072018}
.headerRow{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
.title{font-size:16px;font-weight:800}
.subtitle{color:var(--muted);margin-top:6px;font-size:13px}

/* result layout */
.plateBig{font-size:48px;font-weight:900;letter-spacing:0.08em;color:var(--olive)}
.meta{color:var(--muted);font-weight:600;margin-top:6px}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:14px}
.primary{background:#fbfdff;padding:12px;border-radius:12px;border:1px solid #eef3f6}
.primary h4{margin:0;color:var(--muted);font-weight:700}
.primary .val{margin-top:6px;font-weight:900;font-size:1.1rem;color:#072018}

/* extras */
.extras{margin-top:14px}
.row{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px;background:#fff;border:1px solid #eef3f6;margin-top:8px}
.smallMuted{color:var(--muted);font-size:13px}

/* fallback/manual */
.manualWrap{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
input[type=text]{padding:10px;border-radius:10px;border:1px solid #e6eefc;min-width:160px}

/* raw JSON area */
pre.raw{background:#0b1220;color:#e6eefc;padding:12px;border-radius:8px;margin-top:12px;overflow:auto;max-height:280px}

/* mobile */
@media (max-width:720px){
  .plateBox{width:86%}
  .plateBig{font-size:36px}
  .grid2{grid-template-columns:1fr}
}
</style>
</head>
<body>

<!-- CAMERA fullscreen root -->
<div id="cameraRoot" aria-hidden="false">
  <video id="cam" autoplay playsinline muted></video>

  <div class="overlay" aria-hidden="true">
    <div class="plateBox" id="plateBox">Plaats het kenteken hier</div>
    <div class="hintBadge" id="hintBadge">Automatisch scannen — houd het vak stil</div>
  </div>

  <div class="controls" aria-hidden="true">
    <button class="btn" id="btnManual">Handmatig</button>
    <button class="btn capture" id="btnForce">Maak foto</button>
  </div>
</div>

<!-- App (shown after capture) -->
<div id="app" style="display:none;">
  <div class="card">
    <div class="headerRow">
      <div>
        <div class="title">Kenteken Scanner</div>
        <div class="subtitle">Resultaat — lokaal verwerkt, geen uploads</div>
      </div>
      <div style="text-align:right">
        <div class="smallMuted">Status</div>
        <div id="statusSmall" style="font-weight:800">klaar</div>
      </div>
    </div>

    <div id="resultCard" style="display:none;margin-top:14px">
      <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap">
        <div>
          <div id="resPlate" class="plateBig">—</div>
          <div id="resBrandModel" class="meta">—</div>
        </div>
        <div style="text-align:right">
          <div class="smallMuted">Eerste toelating</div>
          <div id="resFirst" style="font-weight:900"></div>
        </div>
      </div>

      <div class="grid2">
        <div class="primary">
          <h4>Catalogusprijs</h4>
          <div id="resPrice" class="val">—</div>
        </div>
        <div class="primary">
          <h4>Vermogen</h4>
          <div id="resPower" class="val">—</div>
          <div class="smallMuted" id="resPowerExtra"></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px">
        <div class="primary">
          <h4>Torque (Nm)</h4>
          <div id="resTorque" class="val">—</div>
        </div>
        <div class="primary">
          <h4>Massa</h4>
          <div id="resMass" class="val">—</div>
        </div>
      </div>

      <div class="extras">
        <h4 class="smallMuted">Extra informatie</h4>
        <div id="extraRows"></div>
      </div>

      <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
        <button class="btn secondary" id="btnRetry">Opnieuw scannen</button>
        <button class="btn" id="btnManual2">Handmatig kenteken</button>
        <button class="btn" id="btnRaw">Toon raw</button>
      </div>

      <pre id="rawJson" class="raw" style="display:none"></pre>
    </div>

    <div id="noResult" style="display:none;margin-top:14px">
      <div style="font-weight:800">Herkennen niet gelukt</div>
      <div class="smallMuted" style="margin-top:6px">Probeer opnieuw of vul handmatig het kenteken in.</div>
      <div class="manualWrap">
        <input type="text" id="manualPlateInput" placeholder="Bijv: AB-12-CD">
        <button class="btn" id="manualSearchBtn">Zoek</button>
        <button class="btn secondary" id="manualRetryBtn">Opnieuw foto</button>
      </div>
      <div id="manualMsg" style="margin-top:8px;color:#a00"></div>
    </div>
  </div>
</div>

<!-- canavs for processing (hidden) -->
<canvas id="capCanvas" style="display:none"></canvas>
<canvas id="procCanvas" style="display:none"></canvas>

<!-- Tesseract.js -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

<script>
/* ========== Config & State ========== */
const video = document.getElementById('cam');
const cameraRoot = document.getElementById('cameraRoot');
const plateBox = document.getElementById('plateBox');
const hintBadge = document.getElementById('hintBadge');
const btnForce = document.getElementById('btnForce');
const btnManual = document.getElementById('btnManual');

const app = document.getElementById('app');
const resultCard = document.getElementById('resultCard');
const noResult = document.getElementById('noResult');
const statusSmall = document.getElementById('statusSmall');
const resPlate = document.getElementById('resPlate');
const resBrandModel = document.getElementById('resBrandModel');
const resFirst = document.getElementById('resFirst');
const resPrice = document.getElementById('resPrice');
const resPower = document.getElementById('resPower');
const resPowerExtra = document.getElementById('resPowerExtra');
const resTorque = document.getElementById('resTorque');
const resMass = document.getElementById('resMass');
const extraRows = document.getElementById('extraRows');
const rawJson = document.getElementById('rawJson');

const btnRetry = document.getElementById('btnRetry');
const btnManual2 = document.getElementById('btnManual2');
const btnRaw = document.getElementById('btnRaw');
const manualPlateInput = document.getElementById('manualPlateInput');
const manualSearchBtn = document.getElementById('manualSearchBtn');
const manualRetryBtn = document.getElementById('manualRetryBtn');
const manualMsg = document.getElementById('manualMsg');

const capCanvas = document.getElementById('capCanvas');
const procCanvas = document.getElementById('procCanvas');

let stream = null;
let analyzing = false;
let frameTimer = null;
let stabilityCount = 0;
let lastThumb = null;
let lightCandidates = new Map(); // candidate => count
let captureInProgress = false;

const LIGHT_OCR_INTERVAL = 450;     // ms between low-res OCR attempts
const STABLE_REQUIRED = 3;          // repetitions of same candidate to accept
const LIGHT_OCR_SCALE = 0.35;       // low-res scale for quick OCR
const CONFIDENCE_THRESHOLD = 0.6;   // (not strict) used in heuristics

/* ========== Utilities ========== */
function setStatus(txt){ statusSmall.innerText = txt; }
function clamp(n,min,max){return Math.max(min,Math.min(max,n));}
function cleanAlnum(s){ return String(s||'').toUpperCase().replace(/[^A-Z0-9]/g,''); }
function formatDate(ymd){
  if(!ymd) return '';
  const s = String(ymd).trim();
  if(/^\d{8}$/.test(s)){ const y=s.slice(0,4), m=s.slice(4,6), d=s.slice(6,8); return `${d}-${m}-${y}`; }
  return s;
}
function getFirst(obj, keys){
  for(const k of keys) if(obj[k] !== undefined && obj[k] !== null && String(obj[k]).trim() !== '') return obj[k];
  return '';
}

/* simple Dutch-likeness validator (loose) */
function isLikelyDutchPlate(p){
  if(!p) return false;
  const s = cleanAlnum(p);
  if(s.length < 4 || s.length > 8) return false;
  const letters = (s.match(/[A-Z]/g)||[]).length;
  const digits = (s.match(/[0-9]/g)||[]).length;
  return (letters >= 2 && digits >= 2);
}

/* correct common OCR confusions and generate variants */
function generateVariants(base){
  base = String(base||'').toUpperCase().replace(/[^A-Z0-9]/g,'');
  if(!base) return [];
  const mapPairs = [['0','O'],['1','I'],['5','S'],['8','B'],['2','Z'],['6','G']];
  const variants = new Set([base]);
  for(const [a,b] of mapPairs){
    if(base.includes(a)) variants.add(base.split(a).join(b));
    if(base.includes(b)) variants.add(base.split(b).join(a));
  }
  // two-step combos
  const arr = Array.from(variants);
  for(let i=0;i<arr.length;i++){
    for(let j=0;j<mapPairs.length;j++){
      const [a,b] = mapPairs[j];
      if(arr[i].includes(a)) variants.add(arr[i].split(a).join(b));
      if(arr[i].includes(b)) variants.add(arr[i].split(b).join(a));
    }
  }
  return Array.from(variants);
}

/* scoring for candidate (simple heuristic) */
function scorePlate(p){
  if(!p) return 0;
  const s = cleanAlnum(p);
  let score = 0;
  const letters = (s.match(/[A-Z]/g)||[]).length;
  const digits = (s.match(/[0-9]/g)||[]).length;
  if(s.length>=4 && s.length<=8) score += 20;
  score += letters*2 + digits*2;
  if(/[A-Z].*[0-9]|[0-9].*[A-Z]/.test(s)) score += 6;
  score -= Math.abs(s.length - 6); // prefer length ~6
  // small bonus for patterns like 2-2-2
  if(/^[A-Z]{2}[0-9]{2}[A-Z]{2}$/.test(s)) score += 8;
  return score;
}

/* ========== CAMERA & Light OCR loop ========== */

async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    await video.play();
    cameraRoot.style.display = 'flex';
    app.style.display = 'none';
    setStatus('Scanner actief — houd het vak stil');
    // start light OCR loop
    analyzing = true;
    lightCandidates.clear();
    scheduleLightOCR();
  } catch(err){
    console.error('camera start failed', err);
    showApp();
    showNoResult('Kon camera niet openen: ' + (err.message || err));
  }
}

function stopCamera(){
  analyzing = false;
  if(frameTimer) { clearTimeout(frameTimer); frameTimer = null; }
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
  cameraRoot.style.display = 'none';
}

/* schedule lightweight OCR of the cropped plate area (low res) */
function scheduleLightOCR(){
  if(!analyzing || captureInProgress) return;
  frameTimer = setTimeout(async ()=>{
    try {
      await doLightOCR();
    } catch(e){
      console.warn('lightOCR err', e);
    }
    scheduleLightOCR();
  }, LIGHT_OCR_INTERVAL);
}

/* create a small crop of the video as thumbnail for fast OCR */
async function doLightOCR(){
  if(!video.videoWidth || !video.videoHeight) return;
  // crop to plateBox region relative to video display (account for object-fit:cover)
  const crop = cropToPlateBoxCanvas();
  if(!crop) return;
  // create low-res scaled canvas for quick OCR
  const w = Math.max(160, Math.round(crop.width * LIGHT_OCR_SCALE));
  const h = Math.max(40, Math.round(crop.height * LIGHT_OCR_SCALE));
  const tmp = document.createElement('canvas');
  tmp.width = w; tmp.height = h;
  const ctx = tmp.getContext('2d');
  ctx.drawImage(crop.canvas, 0, 0, crop.width, crop.height, 0,0,w,h);

  // quick preprocessing: grayscale + small contrast
  const imgData = ctx.getImageData(0,0,w,h);
  for(let i=0;i<imgData.data.length;i+=4){
    const r = imgData.data[i], g=imgData.data[i+1], b=imgData.data[i+2];
    let gray = 0.2126*r + 0.7152*g + 0.0722*b;
    gray = gray * 1.05; // slight contrast
    imgData.data[i]=imgData.data[i+1]=imgData.data[i+2]=gray;
  }
  ctx.putImageData(imgData,0,0);

  // run light Tesseract on TMP (fast, but low-res)
  try {
    const dataUrl = tmp.toDataURL('image/jpeg',0.6);
    const res = await Tesseract.recognize(dataUrl, 'eng', {
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -',
      tessedit_pageseg_mode: 7
    });
    const text = (res && res.data && res.data.text) ? res.data.text : '';
    const tokens = extractPlateCandidates(text);
    // increment candidate counters
    let foundAny = false;
    for(const t of tokens){
      const cleaned = cleanAlnum(t);
      if(!cleaned) continue;
      foundAny = true;
      // add variants too
      const variants = generateVariants(cleaned);
      for(const v of variants){
        const prev = lightCandidates.get(v) || 0;
        lightCandidates.set(v, prev + 1);
      }
    }
    // check if any candidate reached confidence (repetition + heuristics)
    if(foundAny){
      // create ranked array
      const arr = Array.from(lightCandidates.entries()).map(([k,v]) => ({k,v,score:scorePlate(k)}));
      arr.sort((a,b) => (b.v*2 + b.score) - (a.v*2 + a.score));
      const top = arr[0];
      if(top && (top.v >= STABLE_REQUIRED || top.score >= 26)){
        // accept as good candidate -> perform high-res capture and final pipeline
        console.log('Auto-accept candidate', top);
        await finalizeCaptureWithCandidate(top.k);
      }
    } else {
      // gradually decay counters so false positives drop
      for(const [k,v] of lightCandidates.entries()){
        const nv = Math.max(0, v - 1);
        if(nv===0) lightCandidates.delete(k); else lightCandidates.set(k, nv);
      }
    }
  } catch(e){
    console.warn('light OCR error', e);
  }
}

/* ========== Capture & full-res OCR pipeline ========== */

async function finalizeCaptureWithCandidate(candidateGuess){
  if(captureInProgress) return;
  captureInProgress = true;
  setStatus('Bevestigen en hoge-res foto maken voor controle...');
  // small delay for UX
  await new Promise(r=>setTimeout(r, 220));
  // do a high-res crop from video and run multiple heavy OCR passes
  const crop = cropToPlateBoxCanvas();
  if(!crop){ captureInProgress=false; return; }
  // run multi-pass OCR on several preprocessed canvases (original, sharpen, binarize, upscale)
  const canvases = [];
  canvases.push(cloneCanvas(crop.canvas));                                   // original
  canvases.push(greyscaleContrastBinarize(cloneCanvas(crop.canvas),1.1));     // binary-ish
  canvases.push(sharpenCanvas(cloneCanvas(crop.canvas)));                     // sharpen
  canvases.push(upscaleCanvas(cloneCanvas(crop.canvas),2));                   // upscale
  canvases.push(upscaleCanvas(greyscaleContrastBinarize(cloneCanvas(crop.canvas),1.2),2));

  const candidateScores = new Map(); // plate -> score
  for(const c of canvases){
    try{
      const dataUrl = c.toDataURL('image/jpeg',0.9);
      const res = await Tesseract.recognize(dataUrl, 'eng', {
        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -',
        tessedit_pageseg_mode: 7
      });
      const text = (res && res.data && res.data.text) ? res.data.text : '';
      const tokens = extractPlateCandidates(text);
      for(const t of tokens){
        const cleaned = cleanAlnum(t);
        if(!cleaned) continue;
        const variants = generateVariants(cleaned);
        for(const v of variants){
          const prev = candidateScores.get(v) || 0;
          candidateScores.set(v, prev + 1);
        }
      }
    } catch(err){
      console.warn('heavy OCR pass failed', err);
    }
  }

  // ensure candidateGuess is also considered
  if(candidateGuess){
    const g = cleanAlnum(candidateGuess);
    const prev = candidateScores.get(g) || 0;
    candidateScores.set(g, prev + 3);
  }

  // rank candidates by combined heuristic (occurrence + scorePlate)
  const ranked = Array.from(candidateScores.entries()).map(([k,v]) => ({plate:k,count:v,score: v*2 + scorePlate(k)}));
  ranked.sort((a,b)=>b.score - a.score);

  let chosen = null;
  if(ranked.length){
    // pick first that meets likely Dutch check or high score
    for(const r of ranked){
      if(isLikelyDutchPlate(r.plate) || r.score >= 30){
        chosen = r.plate;
        break;
      }
    }
    if(!chosen) chosen = ranked[0].plate;
  }

  // STOP camera and show UI
  stopCamera();
  showApp();

  if(!chosen){
    // show manual fallback
    showNoResult('Geen betrouwbaar kenteken gevonden.');
    captureInProgress = false;
    return;
  }

  // final normalization: format with optional dashes if length fits 6
  const finalPlate = formatPlateDisplay(chosen);

  setStatus('Kenteken herkend: ' + finalPlate);
  // fetch RDW and render
  await fetchAndRenderRDW(finalPlate);

  captureInProgress = false;
}

/* ========== Image processing helpers (canvas ops) ========== */

function cropToPlateBoxCanvas(){
  // compute plateBox relative to video element and map to underlying video pixels (object-fit:cover)
  const vb = video.getBoundingClientRect();
  const pb = plateBox.getBoundingClientRect();
  const vidW = video.videoWidth, vidH = video.videoHeight;
  if(!vidW || !vidH) return null;
  const elW = vb.width, elH = vb.height;
  const scale = Math.max(vidW/elW, vidH/elH); // cover
  const displayedWidth = vidW/scale, displayedHeight = vidH/scale;
  const offsetX = (elW - displayedWidth)/2, offsetY = (elH - displayedHeight)/2;
  const relX = pb.left - vb.left - offsetX;
  const relY = pb.top - vb.top - offsetY;
  const sx = Math.max(0, Math.round(relX * scale));
  const sy = Math.max(0, Math.round(relY * scale));
  const sw = Math.round(pb.width * scale);
  const sh = Math.round(pb.height * scale);

  capCanvas.width = sw; capCanvas.height = sh;
  const ctx = capCanvas.getContext('2d');
  ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
  return {canvas: capCanvas, width: sw, height: sh};
}

function cloneCanvas(src){
  const c = document.createElement('canvas');
  c.width = src.width; c.height = src.height;
  c.getContext('2d').drawImage(src,0,0);
  return c;
}

function upscaleCanvas(src, scale=2){
  procCanvas.width = src.width * scale; procCanvas.height = src.height * scale;
  const ctx = procCanvas.getContext('2d');
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(src, 0, 0, procCanvas.width, procCanvas.height);
  return procCanvas;
}

function sharpenCanvas(src){
  procCanvas.width = src.width; procCanvas.height = src.height;
  const ctx = procCanvas.getContext('2d');
  ctx.filter = 'contrast(120%) saturate(100%)';
  ctx.drawImage(src,0,0);
  ctx.filter = 'none';
  return procCanvas;
}

function greyscaleContrastBinarize(src, contrast=1.05){
  procCanvas.width = src.width; procCanvas.height = src.height;
  const ctx = procCanvas.getContext('2d');
  ctx.drawImage(src,0,0);
  const img = ctx.getImageData(0,0,procCanvas.width,procCanvas.height);
  const d = img.data;
  let sum=0;
  for(let i=0;i<d.length;i+=4) sum += (d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
  const avg = sum/(d.length/4);
  const threshold = Math.max(100, avg * 0.95);
  for(let i=0;i<d.length;i+=4){
    const gray = Math.round(d[i]*0.299 + d[i+1]*0.587 + d[i+2]*0.114);
    const v = (gray*contrast > threshold) ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(img,0,0);
  return procCanvas;
}

/* ========== OCR helpers ========== */

function extractPlateCandidates(text){
  if(!text) return [];
  const cleaned = text.toUpperCase().replace(/[^A-Z0-9 \-\n]/g,' ');
  const tokens = cleaned.split(/[\s\n]+/).filter(Boolean);
  const candidates = tokens.map(t => t.replace(/[^A-Z0-9]/g,'')).filter(t => t.length >= 4 && t.length <= 8);
  // merge adjacent tokens into combined patterns
  for(let i=0;i<tokens.length-1;i++){
    const t1 = tokens[i].replace(/[^A-Z0-9]/g,'');
    const t2 = tokens[i+1].replace(/[^A-Z0-9]/g,'');
    const j = t1+t2;
    if(j.length>=4 && j.length<=8) candidates.push(j);
  }
  return Array.from(new Set(candidates));
}

function formatPlateDisplay(plate){
  // If 6 characters, display as XX-00-XX style
  const p = cleanAlnum(plate);
  if(p.length===6) return p.slice(0,2)+'-'+p.slice(2,4)+'-'+p.slice(4);
  return plate;
}

/* ========== RDW lookup & rendering ==========
   - main dataset: m9d7-ebf2
   - extras: sample datasets (8ys7-d773, vez5-84b4) - best-effort
========================================== */

async function lookupRDWBase(kent){
  const p = cleanAlnum(kent);
  if(!p) return [];
  const url = `https://opendata.rdw.nl/resource/m9d7-ebf2.json?kenteken=${p}`;
  const r = await fetch(url);
  if(!r.ok) throw new Error('RDW basis fout: ' + r.status);
  return r.json();
}
async function lookupRDWExtra1(kent){ // example: brandstof/vermogen table
  const p = cleanAlnum(kent);
  if(!p) return [];
  try{
    const r = await fetch(`https://opendata.rdw.nl/resource/8ys7-d773.json?kenteken=${p}`);
    if(!r.ok) throw new Error('no extra1');
    return r.json();
  } catch(e){ return []; }
}
async function lookupRDWExtra2(kent){ // example: motor details table (best-effort)
  const p = cleanAlnum(kent);
  if(!p) return [];
  try{
    const r = await fetch(`https://opendata.rdw.nl/resource/vez5-84b4.json?kenteken=${p}`);
    if(!r.ok) throw new Error('no extra2');
    return r.json();
  } catch(e){ return []; }
}

async function fetchAndRenderRDW(plate){
  setStatus('RDW opvragen...');
  try{
    const base = await lookupRDWBase(plate);
    if(!base || base.length===0){
      showNoResult('Geen RDW-gegevens gevonden voor '+plate);
      return;
    }
    const data = base[0];
    // try extras (best-effort, may be empty)
    const extra1 = await lookupRDWExtra1(plate);
    const extra2 = await lookupRDWExtra2(plate);

    renderResult(plate, data, (extra1 && extra1[0]) ? extra1[0] : null, (extra2 && extra2[0]) ? extra2[0] : null);
  } catch(err){
    console.error('RDW fetch error', err);
    showNoResult('Fout bij RDW-opvraag: ' + (err.message || err));
  }
}

function renderResult(plate, data, extra1, extra2){
  // primary
  resPlate.innerText = formatPlateDisplay(plate);
  const merk = getFirst(data,['merk']) || '';
  const model = getFirst(data,['handelsbenaming','uitvoering']) || '';
  resBrandModel.innerText = [merk,model].filter(Boolean).join(' • ');
  resFirst.innerText = formatDate(getFirst(data,['datum_eerste_toelating','datum_eerste_toelating_in_nederland']));

  // price
  const priceRaw = getFirst(data,['catalogusprijs','catalogusprijs_euro','catalogus_prijs']);
  if(priceRaw && String(priceRaw).trim()!==''){
    const n = Number(String(priceRaw).replace(/[^\d]/g,''));
    resPrice.innerText = isNaN(n) ? String(priceRaw) : ('€ ' + n.toLocaleString('nl-NL'));
  } else resPrice.innerText = 'Onbekend';

  // power: check extras first, then base
  let powerVal = null;
  if(extra1) powerVal = getFirst(extra1,['vermogen_kW','vermogen_pk','vermogen']);
  if(!powerVal) powerVal = getFirst(data, ['vermogen','vermogen_kW','vermogen_pk']);
  let powerText = '—'; let powerExtra = '';
  if(powerVal){
    const num = Number(String(powerVal).replace(/[^\d\.-]/g,''));
    if(!isNaN(num)){
      if(num > 200){ powerText = `${num} pk`; powerExtra = `${Math.round(num/1.35962*10)/10} kW`; }
      else { powerText = `${num} kW (${Math.round(num*1.35962*10)/10} pk)`; }
    } else powerText = String(powerVal);
  }
  resPower.innerText = powerText;
  resPowerExtra.innerText = powerExtra;

  // torque — try extra2 first then base
  let torque = null;
  if(extra2) torque = getFirst(extra2,['koppel','koppel_nm','maximum_koppel','max_koppel']);
  if(!torque) torque = getFirst(data, ['koppel','koppel_nm','maximale_koppel']);
  resTorque.innerText = torque ? String(torque) : '—';

  // mass
  const mass = getFirst(data,['massa_rijklaar','massa_ledig_voertuig','toegestane_maximum_massa_voertuig','massa']);
  resMass.innerText = mass ? String(mass)+' kg' : '—';

  // extras
  extraRows.innerHTML = '';
  const fieldMap = [
    ['Brandstof', ['brandstof_omschrijving','brandstof']],
    ['Kleur', ['eerste_kleur','tweede_kleur']],
    ['Zitplaatsen', ['aantal_zitplaatsen']],
    ['Deuren', ['aantal_deuren']],
    ['APK vervaldatum', ['vervaldatum_apk']],
    ['VIN / chassis', ['chassisnummer','voertuig_identificatienummer']],
    ['Trekgewicht', ['max_trekgewicht','max_trekgewicht_massa']],
    ['CO₂', ['co2_uitstoot','co2']]
  ];
  for(const [label, keys] of fieldMap){
    const v = getFirst(data, keys);
    if(v){
      const div = document.createElement('div');
      div.className='row';
      div.innerHTML = `<div class="smallMuted">${label}</div><div style="font-weight:900">${v}</div>`;
      extraRows.appendChild(div);
    }
  }

  rawJson.style.display = 'none';
  rawJson.textContent = JSON.stringify({base:data, extra1:extra1, extra2:extra2}, null, 2);
  resultCard.style.display = 'block';
  noResult.style.display = 'none';
  app.style.display = 'block';
  setStatus('Klaar');
}

/* ========== UI: show app / fallback ========== */
function showApp(){
  app.style.display = 'block';
  cameraRoot.style.display = 'none';
}
function showNoResult(msg){
  resultCard.style.display = 'none';
  noResult.style.display = 'block';
  manualMsg.innerText = msg || '';
  app.style.display = 'block';
  setStatus('klaar');
}

/* ========== Events ========== */
btnForce.addEventListener('click', async ()=> {
  // user-forced capture: trigger full pipeline using current candidate list
  // find top candidate from lightCandidates
  const arr = Array.from(lightCandidates.entries()).map(([k,v])=>({k,v,score:scorePlate(k)}));
  arr.sort((a,b)=> (b.v*2 + b.score) - (a.v*2 + a.score));
  const top = arr[0];
  if(top && isLikelyDutchPlate(top.k)){
    await finalizeCaptureWithCandidate(top.k);
  } else {
    // still attempt capture if user forces
    await finalizeCaptureWithCandidate(top ? top.k : null);
  }
});

btnManual.addEventListener('click', ()=>{
  stopCamera();
  showApp();
  showNoResult('');
});

btnRetry.addEventListener('click', ()=>{
  // restart camera
  resultCard.style.display = 'none';
  rawJson.textContent = '-';
  startCamera();
});

btnManual2.addEventListener('click', ()=>{ resultCard.style.display='none'; showNoResult(''); });

btnRaw.addEventListener('click', ()=>{ rawJson.style.display = rawJson.style.display==='none' ? 'block' : 'none'; });

manualSearchBtn.addEventListener('click', async ()=>{
  const p = manualPlateInput.value.trim();
  if(!p){ manualMsg.innerText = 'Voer een kenteken in'; return; }
  manualMsg.innerText = 'Zoeken...';
  try{
    await fetchAndRenderRDW(p);
    manualMsg.innerText = '';
  } catch(e){ manualMsg.innerText = 'Fout: ' + (e.message || e); }
});

manualRetryBtn.addEventListener('click', ()=>{
  noResult.style.display = 'none';
  manualMsg.innerText = '';
  startCamera();
});

/* ========== bootstrap ========== */
window.addEventListener('load', ()=> {
  startCamera();
});
</script>
</body>
</html>

<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Kenteken Pro — Premium Scanner (NL only)</title>

<!-- Styling: iOS-like, natuurlijke tinten (wit / grijs / olijf / 'krimp' terracotta) -->
<style>
:root{
  --bg:#f6f6f6; --card:#ffffff; --muted:#8b8f93;
  --olive:#6f7b2a; --krimp:#8b5e3c; --shadow: rgba(2,6,23,0.06);
  --radius:14px; --maxw:980px; --accent:var(--olive);
  font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", Roboto, Arial, sans-serif;
}
html,body{height:100%;margin:0;background:var(--bg);color:#072018}
.container{max-width:var(--maxw);margin:20px auto;padding:0 16px;box-sizing:border-box}
#cameraRoot{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;z-index:120}
video#cam{width:100%;height:100%;object-fit:cover;display:block}
.overlay{position:absolute;inset:0;pointer-events:none;display:flex;align-items:center;justify-content:center}
.plateBox{
  width:68%; max-width:880px; aspect-ratio:4/1; border-radius:12px;
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.06));
  border: 2px dashed rgba(255,255,255,0.95);
  box-shadow: 0 8px 30px rgba(0,0,0,0.45) inset;
  display:flex;align-items:center;justify-content:center;padding:10px;font-weight:700;color:rgba(255,255,255,0.95);
  letter-spacing:0.06em;text-align:center;
}
.hintBadge{
  position:absolute;top:16px;left:16px;background:var(--card);color:#072018;padding:10px 12px;border-radius:12px;font-weight:700;
  box-shadow:0 8px 20px var(--shadow);
}

/* controls overlay bottom (small) */
.controls{position:absolute;bottom:16px;left:50%;transform:translateX(-50%);display:flex;gap:10px;z-index:140}
.controlBtn{background:var(--card);padding:10px 14px;border-radius:12px;border:0;font-weight:800;box-shadow:0 8px 24px var(--shadow);cursor:pointer}
.controlBtn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.12);color:#fff}

/* APP UI */
#app{display:none;position:relative;z-index:200;padding:18px;margin:22px auto;width:100%;max-width:var(--maxw);box-sizing:border-box}
.card{background:var(--card);border-radius:var(--radius);padding:16px;box-shadow:0 8px 40px var(--shadow);color:#072018}
.headerRow{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
.title{font-size:18px;font-weight:900}
.subtitle{color:var(--muted);margin-top:6px}

/* Top result: brand/model prominent, age visible */
.resultTop{display:flex;justify-content:space-between;gap:12px;align-items:flex-start;flex-wrap:wrap}
.brandModel{font-size:28px;font-weight:900;color:var(--olive);line-height:1}
.plateDisplay{font-size:20px;font-weight:800;color:#072018;opacity:.9;margin-top:6px}
.ageBadge{background:linear-gradient(90deg,var(--krimp),var(--olive));color:white;padding:8px 12px;border-radius:12px;font-weight:900;box-shadow:0 10px 20px rgba(0,0,0,0.12)}

.grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:14px}
.primary{background:#fbfdff;padding:12px;border-radius:12px;border:1px solid #eef3f6}
.primary h4{margin:0;color:var(--muted);font-weight:800}
.primary .val{margin-top:6px;font-weight:900;font-size:1.05rem;color:#072018}

/* extras */
.extras{margin-top:14px}
.row{display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:10px;background:#fff;border:1px solid #eef3f6;margin-top:8px}
.smallMuted{color:var(--muted);font-size:13px}

/* manual fallback */
.manualWrap{display:flex;gap:8px;margin-top:12px;flex-wrap:wrap}
input[type=text]{padding:10px;border-radius:10px;border:1px solid #e6eefc;min-width:160px}

/* raw JSON */
pre.raw{background:#07121b;color:#e6eefc;padding:12px;border-radius:8px;margin-top:12px;overflow:auto;max-height:320px}

/* responsiveness */
@media (max-width:720px){
  .plateBox{width:86%}
  .brandModel{font-size:20px}
  .plateDisplay{font-size:18px}
  .grid2{grid-template-columns:1fr}
}
</style>
</head>
<body>

<!-- CAMERA fullscreen view -->
<div id="cameraRoot" role="main" aria-live="polite">
  <video id="cam" autoplay playsinline muted></video>

  <div class="overlay" aria-hidden="true">
    <div class="plateBox" id="plateBox">Plaats het kenteken in dit vak — wij zoeken automatisch</div>
    <div class="hintBadge" id="hintBadge">Scanner zoekt…</div>
  </div>

  <div class="controls" aria-hidden="true">
    <button class="controlBtn" id="btnCancel">Annuleer</button>
  </div>
</div>

<!-- App area -->
<div class="container" id="app" style="display:none">
  <div class="card">
    <div class="headerRow">
      <div>
        <div class="title">Kenteken Pro — Resultaat</div>
        <div class="subtitle">Alle verwerkingen lokaal. Alleen kenteken wordt gebruikt voor RDW-opvraag.</div>
      </div>
      <div style="text-align:right">
        <div class="smallMuted">Status</div>
        <div id="statusSmall" style="font-weight:900">klaar</div>
      </div>
    </div>

    <div style="margin-top:14px" id="resultCard" aria-live="polite" style="display:none;">
      <div class="resultTop">
        <div>
          <div id="brandModel" class="brandModel">—</div>
          <div id="plateLarge" class="plateDisplay">—</div>
        </div>
        <div style="text-align:right">
          <div class="smallMuted">Leeftijd</div>
          <div id="ageBadge" class="ageBadge">—</div>
        </div>
      </div>

      <div class="grid2">
        <div class="primary">
          <h4>Catalogusprijs</h4>
          <div id="priceVal" class="val">—</div>
        </div>
        <div class="primary">
          <h4>Brandstof</h4>
          <div id="fuelVal" class="val">—</div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px">
        <div class="primary">
          <h4>Vermogen</h4>
          <div id="powerVal" class="val">—</div>
          <div class="smallMuted" id="powerExtra"></div>
        </div>
        <div class="primary">
          <h4>0 → 100 km/h</h4>
          <div id="accelVal" class="val">—</div>
          <div class="smallMuted" id="accelSource"></div>
        </div>
      </div>

      <div class="grid2" style="margin-top:12px">
        <div class="primary">
          <h4>Koppel (Nm)</h4>
          <div id="torqueVal" class="val">—</div>
        </div>
        <div class="primary">
          <h4>Massa</h4>
          <div id="massVal" class="val">—</div>
        </div>
      </div>

      <div class="extras">
        <h4 class="smallMuted">Extra informatie</h4>
        <div id="extraRows"></div>
      </div>

      <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
        <button class="controlBtn" id="btnRescan">Opnieuw scannen</button>
        <button class="controlBtn" id="btnManual">Handmatig kenteken</button>
        <button class="controlBtn" id="btnRaw">Toon raw</button>
      </div>

      <pre id="rawJson" class="raw" style="display:none"></pre>
    </div>

    <div id="noResult" style="display:none;margin-top:14px">
      <div style="font-weight:900">Herkennen niet gelukt</div>
      <div class="smallMuted" style="margin-top:6px">Probeer opnieuw of vul handmatig het kenteken in.</div>
      <div class="manualWrap">
        <input type="text" id="manualInput" placeholder="Bijv: AB-12-CD">
        <button class="controlBtn" id="manualSearchBtn">Zoek</button>
        <button class="controlBtn" id="manualRetryBtn">Opnieuw foto</button>
      </div>
      <div id="manualMsg" style="margin-top:8px;color:#a00"></div>
    </div>
  </div>
</div>

<!-- Hidden canvases -->
<canvas id="capCanvas" style="display:none"></canvas>
<canvas id="procCanvas" style="display:none"></canvas>

<!-- Load OpenCV.js (async) and Tesseract -->
<script async src="https://docs.opencv.org/master/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>

<script>
/* =========================================
   Premium NL Kenteken Scanner - Implementation
   - OpenCV.js for plate detection (best-effort)
   - Tesseract.js for OCR (multi-pass)
   - CarQuery JSONP lookup for performance / 0-100 (best-effort)
   - RDW base + extra datasets for official data
   ========================================= */

/* ---------- Elements ---------- */
const cam = document.getElementById('cam');
const cameraRoot = document.getElementById('cameraRoot');
const plateBox = document.getElementById('plateBox');
const hintBadge = document.getElementById('hintBadge');
const btnCancel = document.getElementById('btnCancel');

const app = document.getElementById('app');
const statusSmall = document.getElementById('statusSmall');
const resultCard = document.getElementById('resultCard');
const noResult = document.getElementById('noResult');
const brandModelEl = document.getElementById('brandModel');
const plateLarge = document.getElementById('plateLarge');
const ageBadge = document.getElementById('ageBadge');
const priceVal = document.getElementById('priceVal');
const fuelVal = document.getElementById('fuelVal');
const powerVal = document.getElementById('powerVal');
const powerExtra = document.getElementById('powerExtra');
const accelVal = document.getElementById('accelVal');
const accelSource = document.getElementById('accelSource');
const torqueVal = document.getElementById('torqueVal');
const massVal = document.getElementById('massVal');
const extraRows = document.getElementById('extraRows');
const rawJson = document.getElementById('rawJson');

const btnRescan = document.getElementById('btnRescan');
const btnManual = document.getElementById('btnManual');
const btnRaw = document.getElementById('btnRaw');
const manualInput = document.getElementById('manualInput');
const manualSearchBtn = document.getElementById('manualSearchBtn');
const manualRetryBtn = document.getElementById('manualRetryBtn');
const manualMsg = document.getElementById('manualMsg');

const capCanvas = document.getElementById('capCanvas');
const procCanvas = document.getElementById('procCanvas');

/* ---------- State ---------- */
let stream = null;
let opencvReady = false;
let tesseractReady = false;
let lightScanActive = false;
let candidateCounts = new Map(); // candidate -> count
let frameTimer = null;
let captureInProgress = false;
let cv = window.cv; // will be set once OpenCV ready

/* ---------- Config ---------- */
const LIGHT_INTERVAL = 450; // ms
const STABLE_REQUIRED = 4;  // occurrences for automatic acceptance
const LIGHT_SCALE = 0.35;
const MIN_PLATE_WIDTH_PX = 120; // minimal plate width in px after crop to run OCR
const SCORE_THRESHOLD = 28; // higher threshold for acceptance
const CURRENT_YEAR = (new Date()).getFullYear();

/* ---------- Utility helpers ---------- */
function setStatus(txt){ statusSmall.innerText = txt; }
function cleanAlnum(s){ return String(s||'').toUpperCase().replace(/[^A-Z0-9]/g,''); }
function formatDate(ymd){ if(!ymd) return ''; const s=String(ymd).trim(); if(/^\d{8}$/.test(s)){const y=s.slice(0,4),m=s.slice(4,6),d=s.slice(6,8);return `${d}-${m}-${y}`;} return s; }
function getFirst(obj, keys){ for(const k of keys) if(obj && obj[k]!==undefined && obj[k]!==null && String(obj[k]).trim()!=='') return obj[k]; return ''; }

/* Dutch-likeness & variants */
function isLikelyDutchPlate(p){
  if(!p) return false;
  const s = cleanAlnum(p);
  if(s.length < 4 || s.length > 8) return false;
  const letters = (s.match(/[A-Z]/g)||[]).length;
  const digits = (s.match(/[0-9]/g)||[]).length;
  return (letters >= 2 && digits >= 2);
}

function generateVariants(base){
  base = cleanAlnum(base);
  if(!base) return [];
  const map = [['0','O'],['1','I'],['5','S'],['8','B'],['2','Z'],['6','G']];
  const variants = new Set([base]);
  for(const [a,b] of map){
    if(base.includes(a)) variants.add(base.split(a).join(b));
    if(base.includes(b)) variants.add(base.split(b).join(a));
  }
  // pairwise combos
  const arr = Array.from(variants);
  for(const s of arr){
    for(const [a,b] of map){
      if(s.includes(a)) variants.add(s.split(a).join(b));
    }
  }
  return Array.from(variants);
}

function scorePlate(p){
  if(!p) return 0;
  const s = cleanAlnum(p);
  let score = 0;
  const letters = (s.match(/[A-Z]/g)||[]).length;
  const digits = (s.match(/[0-9]/g)||[]).length;
  if(s.length>=4 && s.length<=8) score += 24;
  score += letters*3 + digits*3;
  // mixture bonus
  if(/[A-Z].*[0-9]|[0-9].*[A-Z]/.test(s)) score += 6;
  // pattern bonus for XX99XX
  if(/^[A-Z]{2}[0-9]{2}[A-Z]{2}$/.test(s)) score += 10;
  score -= Math.abs(s.length - 6);
  return score;
}

function formatPlateNice(p){
  const s = cleanAlnum(p);
  if(s.length === 6) return s.slice(0,2)+'-'+s.slice(2,4)+'-'+s.slice(4);
  if(s.length === 7) return s.slice(0,2)+'-'+s.slice(2,5)+'-'+s.slice(5); // generic attempt
  return p;
}

/* ---------- OpenCV ready handler ---------- */
function onOpenCVReady(){
  opencvReady = true;
  cv = window.cv;
  console.log('OpenCV ready', cv ? cv.getBuildInformation().split('\n')[0] : 'cv null');
}

/* OpenCV might load async; attach handler if available */
if(window.cv && window.cv['onRuntimeInitialized']){
  window.cv['onRuntimeInitialized'] = onOpenCVReady;
} else {
  // poll
  const checkCv = setInterval(()=>{
    if(window.cv && window.cv['onRuntimeInitialized']){
      clearInterval(checkCv);
      window.cv['onRuntimeInitialized'] = onOpenCVReady;
    }
  }, 300);
}

/* ---------- Start camera & light scan loop ---------- */
async function startCamera(){
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:'environment' }, audio:false });
    cam.srcObject = stream;
    await cam.play();
    cameraRoot.style.display = 'flex';
    app.style.display = 'none';
    setStatus('Zoeken naar kenteken — houd camera rustig');
    candidateCounts.clear();
    lightScanActive = true;
    scheduleLightScan();
  } catch(err){
    console.error('Camera error', err);
    showApp();
    showNoResult('Kon camera niet openen: ' + (err.message || err));
  }
}

function stopCamera(){
  lightScanActive = false;
  if(frameTimer) { clearTimeout(frameTimer); frameTimer = null; }
  if(stream) { stream.getTracks().forEach(t=>t.stop()); stream = null; }
  cameraRoot.style.display = 'none';
}

/* ---------- Light scan: small crop OCR for quick candidates ---------- */
function scheduleLightScan(){
  if(!lightScanActive || captureInProgress) return;
  frameTimer = setTimeout(async ()=>{
    try{ await doLightScanOnce(); }catch(e){ console.warn('light scan err', e); }
    scheduleLightScan();
  }, LIGHT_INTERVAL);
}

async function doLightScanOnce(){
  if(!cam.videoWidth || !cam.videoHeight) return;
  const crop = cropToPlateCanvas(); // returns {canvas, width, height}
  if(!crop) return;
  // small resized for speed
  const w = Math.max(120, Math.round(crop.width * LIGHT_SCALE));
  const h = Math.max(30, Math.round(crop.height * LIGHT_SCALE));
  const tmp = document.createElement('canvas');
  tmp.width = w; tmp.height = h;
  tmp.getContext('2d').drawImage(crop.canvas, 0, 0, crop.width, crop.height, 0, 0, w, h);

  // quick preprocess
  const ctx = tmp.getContext('2d');
  const img = ctx.getImageData(0,0,w,h);
  for(let i=0;i<img.data.length;i+=4){
    const r=img.data[i], g=img.data[i+1], b=img.data[i+2];
    let gray = 0.299*r + 0.587*g + 0.114*b;
    gray = Math.min(255, gray * 1.05);
    img.data[i]=img.data[i+1]=img.data[i+2]=gray;
  }
  ctx.putImageData(img,0,0);

  // run light Tesseract
  try{
    const dataUrl = tmp.toDataURL('image/jpeg', 0.6);
    const res = await Tesseract.recognize(dataUrl, 'eng', {
      tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -',
      tessedit_pageseg_mode: 7
    });
    const text = res && res.data && res.data.text ? res.data.text : '';
    const tokens = extractPlateCandidates(text);
    if(tokens.length === 0){
      // decay counts
      for(const [k,v] of candidateCounts.entries()){
        const nv = Math.max(0, v - 1);
        if(nv<=0) candidateCounts.delete(k); else candidateCounts.set(k, nv);
      }
      return;
    }
    // increment counts for tokens and their variants
    for(const tok of tokens){
      const base = cleanAlnum(tok);
      if(!base) continue;
      const variants = generateVariants(base);
      for(const v of variants){
        const prev = candidateCounts.get(v) || 0;
        candidateCounts.set(v, prev + 1);
      }
    }

    // rank candidates
    const arr = Array.from(candidateCounts.entries()).map(([k,v])=>({k,v,score: scorePlate(k)}));
    arr.sort((a,b)=> (b.v*2 + b.score) - (a.v*2 + a.score));
    const top = arr[0];
    if(top && (top.v >= STABLE_REQUIRED || top.score >= SCORE_THRESHOLD + 4)){
      // candidate stable enough — escalate to high-res capture + final OCR
      await finalizeWithCandidate(top.k);
    }
  } catch(err){
    console.warn('light OCR failed', err);
  }
}

/* ---------- Crop to plate region:
   - Try to detect plate with OpenCV (rectangular contour with wide aspect)
   - If fails fallback to center crop matching plateBox size
   ---------- */
function cropToPlateCanvas(){
  // draw current video frame into tmp canvas then attempt detection
  const vw = cam.videoWidth, vh = cam.videoHeight;
  if(!vw || !vh) return null;
  const temp = document.createElement('canvas');
  temp.width = vw; temp.height = vh;
  const tctx = temp.getContext('2d');
  tctx.drawImage(cam, 0, 0, vw, vh);

  // attempt OpenCV detection if available
  if(window.cv && opencvReady){
    try{
      const src = cv.imread(temp);
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      const blur = new cv.Mat();
      cv.bilateralFilter(gray, blur, 9, 75, 75);
      const edged = new cv.Mat();
      cv.Canny(blur, edged, 50, 200);
      // dilate to connect
      const M = cv.Mat.ones(3,3,cv.CV_8U);
      cv.dilate(edged, edged, M);
      // find contours
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(edged, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      let bestRect = null;
      for(let i=0;i<contours.size();i++){
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if(approx.rows === 4){ // quadrilateral
          const rect = cv.boundingRect(approx);
          const ar = rect.width / rect.height;
          const area = rect.width * rect.height;
          if(ar > 2.2 && ar < 6 && area > (vw*vh*0.002) ){ // plate-like aspect and min area
            // prefer wide and reasonably sized ones near center
            const centerDist = Math.hypot(rect.x + rect.width/2 - vw/2, rect.y + rect.height/2 - vh/2);
            const score = area - centerDist*2 + (ar>3?20:0);
            if(!bestRect || score > bestRect.score) bestRect = {rect,score};
          }
        }
        approx.delete(); cnt.delete();
      }
      // cleanup
      M.delete(); contours.delete(); hierarchy.delete(); edged.delete(); blur.delete(); gray.delete();
      src.delete();

      if(bestRect && bestRect.rect.width >= MIN_PLATE_WIDTH_PX){
        const r = bestRect.rect;
        capCanvas.width = r.width; capCanvas.height = r.height;
        const cctx = capCanvas.getContext('2d');
        cctx.drawImage(temp, r.x, r.y, r.width, r.height, 0, 0, r.width, r.height);
        return {canvas: capCanvas, width:r.width, height:r.height};
      }
    } catch(e){
      console.warn('OpenCV detection failed', e);
      // fallback to center-crop later
    }
  }

  // Fallback: crop center area based on overlay plateBox DOM size
  const vb = cam.getBoundingClientRect();
  const pb = plateBox.getBoundingClientRect();
  const scale = Math.max(vw / vb.width, vh / vb.height); // cover
  const displayedW = vw/scale, displayedH = vh/scale;
  const offsetX = (vb.width - displayedW)/2, offsetY = (vb.height - displayedH)/2;
  const relX = pb.left - vb.left - offsetX;
  const relY = pb.top - vb.top - offsetY;
  const sx = Math.max(0, Math.round(relX * scale));
  const sy = Math.max(0, Math.round(relY * scale));
  const sw = Math.max(120, Math.round(pb.width * scale));
  const sh = Math.max(40, Math.round(pb.height * scale));
  capCanvas.width = sw; capCanvas.height = sh;
  const ctx = capCanvas.getContext('2d');
  ctx.drawImage(cam, sx, sy, sw, sh, 0, 0, sw, sh);
  return {canvas: capCanvas, width:sw, height:sh};
}

/* ---------- Finalize pipeline: high-res multi-pass OCR and selection ---------- */
async function finalizeWithCandidate(candidateGuess){
  if(captureInProgress) return;
  captureInProgress = true;
  setStatus('Hoge-res foto & uitgebreide OCR...');
  // capture crop (again)
  const crop = cropToPlateCanvas();
  if(!crop){ captureInProgress=false; showNoResult('Kon afbeelding niet uitsnijden'); return; }

  // build preprocessing canvases
  const canvases = [];
  canvases.push(cloneCanvas(crop.canvas));                           // original
  canvases.push(greyscaleContrastBinarize(cloneCanvas(crop.canvas))); // binarize
  canvases.push(sharpenCanvas(cloneCanvas(crop.canvas)));             // sharpen
  canvases.push(upscaleCanvas(cloneCanvas(crop.canvas), 2));          // upscale
  canvases.push(upscaleCanvas(greyscaleContrastBinarize(cloneCanvas(crop.canvas),1.15),2));

  const candidateScores = new Map();
  for(const c of canvases){
    try{
      const dataUrl = c.toDataURL('image/jpeg', 0.92);
      const res = await Tesseract.recognize(dataUrl, 'eng', {
        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -',
        tessedit_pageseg_mode: 7
      });
      const text = res && res.data && res.data.text ? res.data.text : '';
      const tokens = extractPlateCandidates(text);
      for(const t of tokens){
        const cleaned = cleanAlnum(t);
        if(!cleaned) continue;
        const variants = generateVariants(cleaned);
        for(const v of variants){
          const prev = candidateScores.get(v) || 0;
          candidateScores.set(v, prev + 1);
        }
      }
    } catch(err){
      console.warn('heavy OCR pass failed', err);
    }
  }

  // ensure candidateGuess is prioritized
  if(candidateGuess){
    const g = cleanAlnum(candidateGuess);
    const prev = candidateScores.get(g) || 0;
    candidateScores.set(g, prev + 4);
  }

  // rank
  const ranked = Array.from(candidateScores.entries()).map(([k,v])=>({plate:k,count:v,score: v*2 + scorePlate(k)}));
  ranked.sort((a,b)=> b.score - a.score);

  let chosen = null;
  if(ranked.length){
    for(const r of ranked){
      if(isLikelyDutchPlate(r.plate) && r.score >= SCORE_THRESHOLD) { chosen = r.plate; break; }
    }
    if(!chosen) chosen = ranked[0].plate;
  }

  // stop camera
  stopCamera();
  showApp();
  if(!chosen){
    showNoResult('Geen betrouwbaar kenteken gevonden na OCR.');
    captureInProgress = false; return;
  }

  const finalPlate = formatPlateNice(chosen);
  setStatus('Kenteken herkend: ' + finalPlate);
  // RDW + CarQuery pipeline
  await fetchAndRenderData(finalPlate);
  captureInProgress = false;
}

/* ---------- Canvas helpers: clone, upscale, sharpen, binarize ---------- */
function cloneCanvas(src){
  const c = document.createElement('canvas');
  c.width = src.width; c.height = src.height;
  c.getContext('2d').drawImage(src,0,0);
  return c;
}
function upscaleCanvas(src, scale=2){
  procCanvas.width = src.width * scale; procCanvas.height = src.height * scale;
  const ctx = procCanvas.getContext('2d');
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  ctx.drawImage(src,0,0,procCanvas.width,procCanvas.height);
  return procCanvas;
}
function sharpenCanvas(src){
  procCanvas.width = src.width; procCanvas.height = src.height;
  const ctx = procCanvas.getContext('2d');
  ctx.filter = 'contrast(120%) saturate(100%)';
  ctx.drawImage(src,0,0);
  ctx.filter = 'none';
  return procCanvas;
}
function greyscaleContrastBinarize(src, contrast=1.08){
  procCanvas.width = src.width; procCanvas.height = src.height;
  const ctx = procCanvas.getContext('2d');
  ctx.drawImage(src,0,0);
  const img = ctx.getImageData(0,0,procCanvas.width,procCanvas.height);
  const d = img.data;
  let sum = 0;
  for(let i=0;i<d.length;i+=4) sum += (0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
  const avg = sum/(d.length/4);
  const threshold = Math.max(100, avg * 0.96);
  for(let i=0;i<d.length;i+=4){
    const gray = Math.round(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
    const v = (gray*contrast > threshold) ? 255 : 0;
    d[i]=d[i+1]=d[i+2]=v;
  }
  ctx.putImageData(img,0,0);
  return procCanvas;
}

/* ---------- OCR util: extract plate-like tokens ---------- */
function extractPlateCandidates(text){
  if(!text) return [];
  const cleaned = text.toUpperCase().replace(/[^A-Z0-9 \-\n]/g,' ');
  const tokens = cleaned.split(/[\s\n]+/).filter(Boolean);
  const candidates = tokens.map(t => t.replace(/[^A-Z0-9]/g,'')).filter(t => t.length >= 4 && t.length <= 8);
  // merge adjacent tokens (AB 12 CD -> AB12CD)
  for(let i=0;i<tokens.length-1;i++){
    const t1 = tokens[i].replace(/[^A-Z0-9]/g,'');
    const t2 = tokens[i+1].replace(/[^A-Z0-9]/g,'');
    const j = t1 + t2;
    if(j.length >=4 && j.length <=8) candidates.push(j);
  }
  return Array.from(new Set(candidates));
}

/* ---------- Fetch RDW & CarQuery & render ---------- */
async function lookupRDWBase(plate){
  const p = cleanAlnum(plate);
  if(!p) return [];
  const url = `https://opendata.rdw.nl/resource/m9d7-ebf2.json?kenteken=${p}`;
  const resp = await fetch(url);
  if(!resp.ok) throw new Error('RDW basis fout: '+resp.status);
  return await resp.json();
}
async function lookupRDWExtra1(plate){
  const p = cleanAlnum(plate);
  if(!p) return [];
  try{
    const r = await fetch(`https://opendata.rdw.nl/resource/8ys7-d773.json?kenteken=${p}`);
    if(!r.ok) throw new Error('no extra1');
    return await r.json();
  } catch(e){ return []; }
}
async function lookupRDWExtra2(plate){
  const p = cleanAlnum(plate);
  if(!p) return [];
  try{
    const r = await fetch(`https://opendata.rdw.nl/resource/vez5-84b4.json?kenteken=${p}`);
    if(!r.ok) throw new Error('no extra2');
    return await r.json();
  } catch(e){ return []; }
}

/* CarQuery JSONP helper (returns Promise) */
function carQueryGetTrims(make, model, year){
  return new Promise((resolve, reject) => {
    // sanitize
    if(!make || !model) { resolve([]); return; }
    const cbName = '__cqcb_' + Math.random().toString(36).slice(2,9);
    window[cbName] = function(data){
      try{ delete window[cbName]; script.remove(); resolve(data && data.Trims ? data.Trims : (data || [])); }
      catch(e){ delete window[cbName]; script.remove(); resolve([]); }
    };
    const script = document.createElement('script');
    const params = [`callback=${cbName}`, 'cmd=getTrims', `make=${encodeURIComponent(make)}`, `model=${encodeURIComponent(model)}`];
    if(year) params.push(`year=${encodeURIComponent(year)}`);
    script.src = 'https://www.carqueryapi.com/api/0.3/?' + params.join('&');
    script.onerror = ()=>{
      try{ delete window[cbName]; script.remove(); }catch(e){}
      resolve([]);
    };
    document.body.appendChild(script);
    // timeout
    setTimeout(()=>{ if(window[cbName]){ try{ delete window[cbName]; script.remove(); }catch(e){} resolve([]); } }, 8000);
  });
}

/* Estimate 0-100 from power (kW) & mass (kg) if no official data (simple empirical model).
   This is a rough estimate: t = k * sqrt(mass / power) with k ~ 2.5 calibrated for typical cars.
   We show clearly 'geschat' and don't claim exact accuracy.
*/
function estimate0to100(kW, massKg){
  if(!kW || !massKg || kW <= 0 || massKg <= 0) return null;
  const ratio = massKg / kW;
  const t = 2.5 * Math.sqrt(ratio) // calibration factor
  return Math.round(t * 10) / 10;
}

async function fetchAndRenderData(plateDisplay){
  setStatus('RDW en specificaties ophalen…');
  try{
    const rawPlate = cleanAlnum(plateDisplay);
    // RDW base
    const baseArr = await lookupRDWBase(rawPlate);
    if(!baseArr || baseArr.length === 0){
      showNoResult('Geen RDW-data voor ' + plateDisplay);
      return;
    }
    const base = baseArr[0];
    // attempts for extra RDW
    const extra1Arr = await lookupRDWExtra1(rawPlate);
    const extra2Arr = await lookupRDWExtra2(rawPlate);
    const extra1 = (extra1Arr && extra1Arr.length)? extra1Arr[0] : null;
    const extra2 = (extra2Arr && extra2Arr.length)? extra2Arr[0] : null;

    // prepare fields
    const merk = getFirst(base, ['merk']) || '';
    const model = getFirst(base, ['handelsbenaming','uitvoering']) || '';
    const firstDate = formatDate(getFirst(base, ['datum_eerste_toelating','datum_eerste_toelating_in_nederland']));
    // age in years
    let ageText = '';
    try {
      const dparts = firstDate.split('-');
      if(dparts.length===3){
        const yr = Number(dparts[2]);
        if(!isNaN(yr)) ageText = (CURRENT_YEAR - yr) + ' jaar';
      }
    } catch(e){}
    // price
    const priceRaw = getFirst(base, ['catalogusprijs','catalogusprijs_euro','catalogus_prijs']);
    let priceText = 'Onbekend';
    if(priceRaw && String(priceRaw).trim()!==''){
      const num = Number(String(priceRaw).replace(/[^\d]/g,''));
      priceText = isNaN(num) ? String(priceRaw) : ('€ ' + num.toLocaleString('nl-NL'));
    }
    // fuel
    const fuel = getFirst(base, ['brandstof_omschrijving','brandstof']) || getFirst(extra1,['brandstof','brandstof_omschrijving']) || '—';

    // power: try extra1/extra2 then base
    let powerVal = getFirst(extra1, ['vermogen_kW','vermogen_pk','max_vermogen_60_minuten']) || getFirst(base, ['vermogen','vermogen_kW','vermogen_pk','vermogen_massarijklaar']);
    let powerDisplay = '—';
    let powerExtraText = '';
    let powerKW = null;
    if(powerVal){
      const n = Number(String(powerVal).replace(/[^\d\.-]/g,''));
      if(!isNaN(n)){
        // heuristisch bepalen of n is pk/ps or kW
        if(n > 200){ // likely pk
          powerDisplay = `${n} pk`;
          powerKW = Math.round((n * 0.735499) * 10) / 10;
          powerExtraText = `${powerKW} kW`;
        } else {
          powerKW = n;
          const pk = Math.round((powerKW * 1.3596216) * 10) / 10;
          powerDisplay = `${powerKW} kW (${pk} pk)`;
        }
      } else powerDisplay = String(powerVal);
    }

    // torque: try extra2 then base
    let torque = getFirst(extra2, ['koppel','koppel_nm','maximum_koppel']) || getFirst(base, ['koppel','koppel_nm','maximale_koppel']);
    torque = torque ? String(torque) : '—';

    // mass
    const mass = getFirst(base, ['massa_rijklaar','massa_ledig_voertuig','toegestane_maximum_massa_voertuig','massa']) || '';
    const massText = mass ? String(mass) + ' kg' : '—';

    // attempt CarQuery for detailed spec and 0-100
    let accelText = '—';
    let accelSourceText = '';
    try {
      // derive year from firstDate
      let year = null;
      if(firstDate){
        const parts = firstDate.split('-');
        if(parts.length===3) year = Number(parts[2]);
      }
      const trims = await carQueryGetTrims(merk, model.split(' ')[0] || model, year || '');
      if(trims && trims.length){
        // find best trim — choose first with non-empty engine power or 0-100
        let bestTrim = null;
        for(const t of trims){
          if(t.model_engine_power_ps || t.model_engine_power_kw || t.model_engine_torque_nm || t.model_0_to_100_kph || t.model_0_to_60_kph || t.model_engine_power_hp) { bestTrim = t; break; }
        }
        if(!bestTrim) bestTrim = trims[0];
        if(bestTrim){
          // power from CarQuery (PS or kW)
          if(bestTrim.model_engine_power_ps && !powerKW){
            const ps = Number(bestTrim.model_engine_power_ps);
            if(!isNaN(ps)){
              powerKW = Math.round((ps * 0.735499) * 10) / 10;
              powerDisplay = `${ps} pk (${powerKW} kW)`;
            }
          } else if(bestTrim.model_engine_power_kw && !powerKW){
            const kw = Number(bestTrim.model_engine_power_kw);
            if(!isNaN(kw)){
              powerKW = kw;
              powerDisplay = `${kw} kW (${Math.round(kw * 1.3596216 * 10)/10} pk)`;
            }
          }
          // torque
          if(!torque || torque==='—'){
            if(bestTrim.model_engine_torque_nm) torque = bestTrim.model_engine_torque_nm;
          }
          // 0-100
          const possibleAccel = bestTrim.model_0_to_100_kph || bestTrim.model_0_to_60_kph || bestTrim.model_0_to_62mph || bestTrim.model_0_to_60mph;
          if(possibleAccel){
            accelText = possibleAccel + ' s';
            accelSourceText = 'CarQuery (extern)';
          }
        }
      }
    } catch(e){
      console.warn('CarQuery failed', e);
    }

    // If still no accel, estimate using mass & powerKW
    if((!accelText || accelText==='—') && powerKW && mass){
      const est = estimate0to100(powerKW, Number(String(mass).replace(/[^\d]/g,'')));
      if(est){
        accelText = est + ' s';
        accelSourceText = 'Geschat (power-to-weight)';
      }
    }

    // Render UI
    brandModelEl.innerText = (merk ? merk : '') + (merk && model ? ' • ' : '') + (model ? model : '');
    plateLarge.innerText = plateDisplay;
    ageBadge.innerText = ageText || (firstDate ? firstDate : '—');
    priceVal.innerText = priceText;
    fuelVal.innerText = fuel || '—';
    powerVal.innerText = powerDisplay;
    powerExtra.innerText = powerExtraText || '';
    accelVal.innerText = accelText;
    accelSource.innerText = accelSourceText;
    torqueVal.innerText = torque ? torque : '—';
    massVal.innerText = massText;

    // extras
    extraRows.innerHTML = '';
    const fieldMap = [
      ['APK vervaldatum', ['vervaldatum_apk']],
      ['Chassis (VIN)', ['chassisnummer','voertuig_identificatienummer']],
      ['Inrichting', ['inrichting']],
      ['Uitvoering', ['uitvoering']],
      ['Catalogusprijs', ['catalogusprijs']],
      ['CO₂ (g/km)', ['co2_uitstoot','co2']]
    ];
    for(const [lbl, keys] of fieldMap){
      const v = getFirst(base, keys);
      if(v){
        const div = document.createElement('div');
        div.className = 'row';
        div.innerHTML = `<div class="smallMuted">${lbl}</div><div style="font-weight:900">${v}</div>`;
        extraRows.appendChild(div);
      }
    }

    rawJson.style.display = 'none';
    rawJson.textContent = JSON.stringify({base, extra1, extra2}, null, 2);
    resultCard.style.display = 'block';
    noResult.style.display = 'none';
    app.style.display = 'block';
    setStatus('Klaar');
  } catch(err){
    console.error('fetchAndRenderData err', err);
    showNoResult('Fout bij ophalen gegevens: ' + (err.message || err));
  }
}

/* ---------- UI helpers ---------- */
function showApp(){
  app.style.display = 'block';
  cameraRoot.style.display = 'none';
}
function showNoResult(msg){
  resultCard.style.display = 'none';
  noResult.style.display = 'block';
  manualMsg.innerText = msg || '';
  app.style.display = 'block';
  setStatus('klaar');
}

/* ---------- Events ---------- */
btnCancel.addEventListener('click', ()=>{ stopCamera(); showNoResult('Gebruiker annuleerde camera.'); });
btnRescan.addEventListener('click', ()=>{ resultCard.style.display='none'; rawJson.textContent='-'; startCamera(); });
btnManual.addEventListener('click', ()=>{ stopCamera(); showNoResult(''); });
btnRaw.addEventListener('click', ()=>{ rawJson.style.display = rawJson.style.display==='none' ? 'block' : 'none'; });
manualSearchBtn.addEventListener('click', async ()=>{
  const p = manualInput.value.trim();
  if(!p){ manualMsg.innerText='Voer een kenteken in'; return; }
  manualMsg.innerText = 'Zoeken…';
  try{ await fetchAndRenderData(p); manualMsg.innerText = ''; } catch(e){ manualMsg.innerText = 'Fout: '+(e.message||e); }
});
manualRetryBtn.addEventListener('click', ()=>{ noResult.style.display='none'; manualMsg.innerText=''; startCamera(); });

/* ---------- Boot ---------- */
window.addEventListener('load', ()=> { startCamera(); });

/* ---------- End of script ---------- */
</script>
</body>
</html>
